
\documentclass[a4paper, 14pt]{extarticle}
% Поля
%--------------------------------------
\usepackage{geometry}
\geometry{a4paper,tmargin=2cm,bmargin=2cm,lmargin=3cm,rmargin=1cm}
%--------------------------------------


%Russian-specific packages
%--------------------------------------
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc} 
\usepackage[english, main=russian]{babel}

\usepackage{pgfplots}
\pgfplotsset{compat=1.9}

%--------------------------------------

\usepackage{textcomp}

% Красная строка
%--------------------------------------
\usepackage{indentfirst}               
%--------------------------------------             


%Graphics
%--------------------------------------
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{wrapfig}
%--------------------------------------

% Полуторный интервал
%--------------------------------------
\linespread{1.3}                    
%--------------------------------------

%Выравнивание и переносы
%--------------------------------------
% Избавляемся от переполнений
\sloppy
% Запрещаем разрыв страницы после первой строки абзаца
\clubpenalty=10000
% Запрещаем разрыв страницы после последней строки абзаца
\widowpenalty=10000
%--------------------------------------

%Списки
\usepackage{enumitem}

%Подписи
\usepackage{caption} 

%Гиперссылки
\usepackage{hyperref}

\hypersetup {
	unicode=true
}

%Рисунки
%--------------------------------------
\DeclareCaptionLabelSeparator*{emdash}{~--- }
\captionsetup[figure]{labelsep=emdash,font=onehalfspacing,position=bottom}
%--------------------------------------

\usepackage{tempora}
\usepackage{amsmath}
\usepackage{color}
\usepackage{listings}
\lstset{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  extendedchars=\true,
  inputencoding=utf8x,
  frame=L,
  xleftmargin=\parindent,
  language=Python,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{blue},
  commentstyle=\itshape\color{purple},
  identifierstyle=\color{black},
  stringstyle=\color{red},
}

%--------------------------------------
%			НАЧАЛО ДОКУМЕНТА
%--------------------------------------

\begin{document}

%--------------------------------------
%			ТИТУЛЬНЫЙ ЛИСТ
%--------------------------------------
\begin{titlepage}
\thispagestyle{empty}
\newpage


%Шапка титульного листа
%--------------------------------------
\vspace*{-60pt}
\hspace{-65pt}
\begin{minipage}{0.3\textwidth}
\hspace*{-20pt}\centering
\includegraphics[width=\textwidth]{emblem}
\end{minipage}
\begin{minipage}{0.67\textwidth}\small \textbf{
\vspace*{-0.7ex}
\hspace*{-6pt}\centerline{Министерство науки и высшего образования Российской Федерации}
\vspace*{-0.7ex}
\centerline{Федеральное государственное бюджетное образовательное учреждение }
\vspace*{-0.7ex}
\centerline{высшего образования}
\vspace*{-0.7ex}
\centerline{<<Московский государственный технический университет}
\vspace*{-0.7ex}
\centerline{имени Н.Э. Баумана}
\vspace*{-0.7ex}
\centerline{(национальный исследовательский университет)>>}
\vspace*{-0.7ex}
\centerline{(МГТУ им. Н.Э. Баумана)}}
\end{minipage}
%--------------------------------------

%Полосы
%--------------------------------------
\vspace{0pt}
\hspace{-35pt}\rule{\textwidth}{2.3pt}

\vspace*{-20pt}
\hspace{-35pt}\rule{\textwidth}{0.4pt}
%--------------------------------------

\vspace{1ex}
\hspace{-35pt} \noindent \small ФАКУЛЬТЕТ\hspace{80pt} <<Информатика и системы управления>>

\vspace*{-16pt}
\hspace{47pt}\rule{0.83\textwidth}{0.4pt}

\vspace{0.5ex}
\hspace{-35pt} \noindent \small КАФЕДРА\hspace{50pt} <<Теоретическая информатика и компьютерные технологии>>

\vspace*{-16pt}
\hspace{30pt}\rule{0.866\textwidth}{0.4pt}
  
\vspace{11em}

\begin{center}
\Large {\bf Лабораторная работа № 1} \\ 
\large {\bf по курсу <<Теория формальных языков>>} \\ 
\end{center}\normalsize

\vspace{8em}


\begin{flushright}
  {Студент группы ИУ9-51Б Винокурова Е. С.\hspace*{15pt} \\
  \vspace{2ex}
  Преподаватель Непейвода А. Н.\hspace*{15pt}}
\end{flushright}

\bigskip

\vfill
 

\begin{center}
\textsl{Москва 2025}
\end{center}
\end{titlepage}
%--------------------------------------
%		КОНЕЦ ТИТУЛЬНОГО ЛИСТА
%--------------------------------------


\renewcommand{\ttdefault}{pcr}

\setlength{\tabcolsep}{3pt}
\newpage
\setcounter{page}{2}
\section{Задание}

По имеющейся SRS определить:

- завершимость

- конечность классов эквивалентности по НФ (для построения эквивалентностей считаем, что правила могут применяться в обе стороны). Если их конечное число, то построить минимальную систему переписывания, им соответствующую.

- локальную конфлюэнтность и пополняемость по Кнуту-Бендиксу

По SRS $\mathcal{T}$ строится другая SRS $\mathcal{T}'$, которая должна сохранять те же классы эквивалентности. Если исходная SRS завершима, то правила в $\mathcal{T}'$ должны удовлетворять условию убывания левой части относительно правой по выбранному вами фундированному порядку $>$.

Провести автоматическое тестирование предполагаемой эквивалентности двух указанных SRS.

\textbf{Фазз-тестирование эквивалентности:} строится случайное слово $\omega$ и случайная цепочка переписываний его в $\omega'$ по $\mathcal{T}'$. Проверить, можно ли получить $\omega'$ из $\omega$ (или наоборот) в рамках правил $\mathcal{T}'$.

\textbf{Метаморфное тестирование:} выбрать инварианты, которые должны сохраняться (либо монотонно изменяться) при переписывании в рамках $\mathcal{T}'$. Порождать случайную цепочку переписываний над случайным словом в $\mathcal{T}'$ и проверить выполнимость инвариантов. Как минимум два разных инварианта.

\textbf{Вариант 4}

fgh $\rightarrow$ fff

fgh $\rightarrow$ ggg

fgh $\rightarrow$ hhh

hh $\rightarrow$ hfhgh

gggg $\rightarrow$ $\varepsilon$


\section{Проверка завершимости}

Рассмотрим два инварианта. Первый инвариант — это количество пар `hh` в строке с учётом перекрытий. Например, для строки `hhh` количество пар будет 2. Второй инвариант — это сумма весов букв `g` в строке в зависимости от контекста. Будем считать, что если `g` находится в подстроке `fhgh`, то вес такого `g` равен 0; если `g` стоит рядом с другим `g` (то есть хотя бы с одной стороны от него находится другой `g`), то вес каждого такого `g` равен 2; во всех остальных случаях вес `g` равен 8. 

Теперь рассмотрим сумму этих двух инвариантов для каждого правила и покажем, что она всегда строго убывает. Обозначим эту сумму через M.

Рассмотрим правило `fgh → fff`. Для левой части `fgh` значение M = 8, а для правой части `fff` M = 0. Вне зависимости от контекста, в котором они находятся, M всегда уменьшается минимум на 8.

Рассмотрим правило `fgh → ggg`. Для `fgh` значение M = 8, а для `ggg` M = 6. Контекст также не уменьшает разницу между левой и правой частями правила, поэтому для этого правила M уменьшается как минимум на 2.

Рассмотрим правило `fgh → hhh`. Для `fgh` значение M = 8, а для `hhh` M = 2. Однако контекст может уменьшить разницу между левой и правой частями. Например, если взять строку `hfgh`, которая переходит в `hhhh`, получим изменение M: 8 → 3, то есть M уменьшается хотя бы на 5.

Рассмотрим правило `hh → hfhgh`. Поскольку граничные буквы подстрок не меняются, контекст не влияет на разницу значений M. Таким образом, для `hh` значение M = 1, а для `hfhgh` M = 0, то есть M убывает на 1.

Рассмотрим правило `gggg → $\varepsilon$`. Для `gggg` значение M = 8, а для `$\varepsilon$` M = 0. Однако при применении этого правила может возникнуть новая подстрока `fgh`, где вес `g` будет 8. Проверим, что это не увеличит M. Пусть есть строка `fgggggh`, для неё M = 10. Применив правило, получим `fgh`, для которой M = 8. Таким образом, даже в этом случае `M` строго уменьшается.

Итак, для всех правил системы M строго убывает, и при этом M всегда неотрицательно. Следовательно, невозможно бесконечно применять правила, и система переписываний является завершимой.

\section{Локальная конфлюэнтность и пополняемость по Кнуту-Бендиксу}
SRS $\mathcal{T}$ локально не конфлюэнтна, так как из слова `fgh` можно получить 3 разных нормальных формы: `fff`, `ggg` и `hfhghfhgh`. 

Построим по алгоритму Кнута-Бендикса систему $\mathcal{T}'$, которая сохраняет те же классы эквивалентности. Рассмотрим систему 

fgh $\rightarrow$ fff

ggg $\rightarrow$ fgh

fgh $\rightarrow$ hhh

hfhgh $\rightarrow$ hh

gggg $\rightarrow$ $\varepsilon$

Здесь слова сначала сравниваются по длинне, если длина одинаковая, то они упорядочиваются лексикографически, где `h` = 1, `f` = 2, `g` = 3. Рассмотрим критические пары.

1. Из `fgh` можно получить `fff` и `hhh, поэтому добавим правило `fff` $\rightarrow$ `hhh`. Можно убрать правило `fgh` $\rightarrow$ `hhh`, так как это можно получить так `fgh` $\rightarrow$ `fff` $\rightarrow$ `hhh`.

2. Из `ffff` можно получить `fhhh` и `hhhf`, добавим правило `fhhh` $\rightarrow$ `hhhf`.

3. Из `gggg` можно получить $\varepsilon$, `ghhh` и `hhhg`, добавим правила `ghhh` $\rightarrow$ `hhhg` и `hhhg` $\rightarrow$ $\varepsilon$. Можно убрать правило `gggg` $\rightarrow$ $\varepsilon$, так как это можно получить так `gggg` $\rightarrow$ `gfgh` $\rightarrow$ `gfff` $\rightarrow$ `ghhh` $\rightarrow$ `hhhg` $\rightarrow$ $\varepsilon$.

4. Из `ffffg` можно получить `f` и `hhhfg`, добавим правило `hhhfg` $\rightarrow$ `f`.

5. Из `fffgh` можно получить `h` и `hhhff`, добавим правило `hhhff` $\rightarrow$ `h`.

6. Из `fgggg` можно получить `f` и `hhhhh`, добавим правило `hhhhh` $\rightarrow$ `f`.

7. Из `ffffff` можно получить `fh` и `hf`, добавим правило `fh` $\rightarrow$ `hf`. Можно убрать правило `fhhh` $\rightarrow$ `hhhf`, так как это можно получить так `fhhh` $\rightarrow$ `hfhh` $\rightarrow$ `hhfh` $\rightarrow$ `hhhf`.

8. Из `hfhgh` можно получить `f` и `hh`, добавим правило `hh` $\rightarrow$ `f`. Можно убрать правило `fhhh` $\rightarrow$ `hhhf`, так как это можно получить так `fhhh` $\rightarrow$ `hfhh` $\rightarrow$ `hhfh` $\rightarrow$ `hhhf`. 

9. Из `fghh` можно получить `ff` и `fgf`, добавим правило `fgf` $\rightarrow$ `ff`. 

10. Из `gggg` можно получить $\varepsilon$, `ghf` и `hfg`, добавим правило `ghf` $\rightarrow$ `hfg` и `hfg` $\rightarrow$ $\varepsilon$. Можно убрать правило `hhhfg` $\rightarrow$ `f`, так как это можно получить `hhhfg` $\rightarrow$ `hh` $\rightarrow$ `f`. Также можно убрать правило `hfhgh` $\rightarrow$ `hh`, так как это можно получить так `hfhgh` $\rightarrow$ `hhfgh` $\rightarrow$ `hh`. Также можно убрать правило `hhhg` $\rightarrow$ $\varepsilon$, так как это можно получить так `hhhg` $\rightarrow$ `hfg` $\rightarrow$ $\varepsilon$.

11. Из `fgfh` можно получить `f`, `hff` и `hffg`, добавим правило `hffg` $\rightarrow$ `hff` и `hff` $\rightarrow$ `f`. 

12. Из `fgfh` можно получить `f` и `fg`, добавим правило `fg` $\rightarrow$ `f`. 

13. Из `hfg` можно получить $\varepsilon$ и `hf`, добавим правило `hf` $\rightarrow$ $\varepsilon$. Можно убрать правило `hhhff` $\rightarrow$ `h`, так как это можно получить `hhhff` $\rightarrow$ `hhf` $\rightarrow$ `h`. Также можно убрать правило `hff` $\rightarrow$ `f`, так как это можно получить так `hff` $\rightarrow$ `f`, применив добавленное правило. Можно убрать правило `hhhhh` $\rightarrow$ `f`, так как это можно получить `hhhhh` $\rightarrow$ `hhhf` $\rightarrow$ `fhf` $\rightarrow$ `f`.

14. Из `fhh` можно получить `ff` и `h`, добавим правило `ff` $\rightarrow$ `h`. 

15. Из `ghf` можно получить $\varepsilon$ и `g`, добавим правило `g` $\rightarrow$ $\varepsilon$. Можно убрать правила `fgf` $\rightarrow$ `ff`, `hfg` $\rightarrow$ $\varepsilon$, `hffg` $\rightarrow$ `hff` и `fg` $\rightarrow$ `f`, так как их можно получить применив добавленное правило.

Критических пар больше нет, то есть система конфлюэнтна, также все действия сохраняли классы эквивалентности, то есть полученная система $\mathcal{T}'$ эквивалентна исходной и имеет вид:

fgh $\rightarrow$ fff

ggg $\rightarrow$ fgh

fff $\rightarrow$ hhh

ghhh $\rightarrow$ hhhg

fh $\rightarrow$ hf

hh $\rightarrow$ f

ghf $\rightarrow$ hfg

hf $\rightarrow$ $\varepsilon$

ff $\rightarrow$ h

g $\rightarrow$ $\varepsilon$

\section{Классы эквивалентности}

Рассмотрим классы эквивалентности полученной системы $\mathcal{T}'$, так как они совпадают с калссами эквивалентности исходной SRS, то $\mathcal{T}$ имеет такие же классы эквивалентности. Построим автомат по этой системе.

\begin{center}
\includegraphics[width=100mm]{b}
\end{center}

Таким образом в SRS $\mathcal{T}$ ровно 3 класса эквивалентности $\varepsilon$, `f` и `h`.

\section{Фазз-тестирование эквивалентности}

Код программы представлен в Листинге 1.
\begin{lstlisting}
import random
from collections import deque

def generate_random_word(length, alphabet):
    return ''.join(random.choice(alphabet) for _ in range(length))

def rule_T(word, rules):
    applicable_rules = []
    for lhs, rhs in rules:
        positions = []
        idx = 0
        while idx <= len(word) - len(lhs):
            if word[idx:idx+len(lhs)] == lhs:
                positions.append(idx)
            idx += 1
        for pos in positions:
            applicable_rules.append((lhs, rhs, pos))
    if not applicable_rules:
        return word, False
    lhs, rhs, pos = random.choice(applicable_rules)
    new_word = word[:pos] + rhs + word[pos+len(lhs):]
    return new_word, True

def apply_rules(word, rules):
    results = set()
    for lhs, rhs in rules:
        idx = 0
        while idx <= len(word) - len(lhs):
            if word[idx:idx+len(lhs)] == lhs:
                new_word = word[:idx] + rhs + word[idx+len(lhs):]
                results.add(new_word)
            idx += 1
        idx = 0
        while idx <= len(word) - len(rhs):
            if word[idx:idx+len(rhs)] == rhs:
                new_word = word[:idx] + lhs + word[idx+len(rhs):]
                results.add(new_word)
            idx += 1
    return results
def reachable(start, target, rules, max_len, max_steps):
    if start == target:
        return True
    f_queue = deque([(start, 0)])
    b_queue = deque([(target, 0)])
    f_visited = {start}
    b_visited = {target}
    while f_queue and b_queue:
        if len(f_queue) <= len(b_queue):
            current_queue, current_visited, other_visited = f_queue, f_visited, b_visited
        else:
            current_queue, current_visited, other_visited = b_queue, b_visited, f_visited
        word, steps = current_queue.popleft()
        if steps >= max_steps:
            continue
        for new_word in apply_rules(word, rules):
            if len(new_word) > max_len:
                continue
            if new_word in other_visited:
                return True
            if new_word not in current_visited:
                current_visited.add(new_word)
                current_queue.append((new_word, steps + 1))
    return False

alphabet = ['f', 'g', 'h']
T = [
    ("fgh", "fff"),
    ("fgh", "ggg"),
    ("fgh", "hhh"),
    ("hh", "hfhgh"),
    ("gggg", "")
]

T1 = [
    ("fgh", "fff"),
    ("ggg", "fgh"),
    ("fff", "hhh"),
    ("ghhh", "hhhg"),
    ("fh", "hf"),
    ("hh", "f"),
    ("fgf", "ff"),
    ("ghf", "hfg"),
    ("hf", ""),
    ("ff", "h"),
    ("g", "")
]
word = generate_random_word(30, alphabet)
sequence = [word]
steps = random.randint(15, 20)
for _ in range(steps):
    word, applied = rule_T(word, T)
    if not applied:
        break
    sequence.append(word)
f = True
for i in range(len(sequence) - 1):
    w_from = sequence[i]
    w_to = sequence[i + 1]
    if not reachable(w_from, w_to, T1, max_len=100, max_steps=15):
        f = False
        print(f"Невозможно переписать '{w_from}' в '{w_to}' в T'")
        break
if f:
    print("Слово достижимо в T'")
\end{lstlisting}

\section{Метаморфоное тестирование}
Были рассмотрены два инварианта.

1. ($|\omega|_f$ - $|\omega|_h$)mod$_3$ этот инвариант не меняется при применении любых правил из систем переписывания $\mathcal{T}'$ и $\mathcal{T}$.

2. \[
\begin{aligned}
M(\omega) ={} & \frac{1}{13}|\omega|_f + \frac{1}{13}|\omega|_g + \frac{1}{26}|\omega|_h - \frac{1}{13}|\omega|_{ff} - \frac{1}{13}|\omega|_{fg} - \frac{1}{26}|\omega|_{fh} - \frac{1}{13}|\omega|_{gf} - \\
&- \frac{1}{13}|\omega|_{gg} - \frac{1}{26}|\omega|_{gh} - \frac{1}{26}|\omega|_{hf} - \frac{1}{26}|\omega|_{hg} - \frac{1}{26}|\omega|_{fhf} - \frac{1}{26}|\omega|_{fhg} - \\
&- \frac{1}{26}|\omega|_{fhh} - \frac{1}{26}|\omega|_{ghf} - \frac{1}{26}|\omega|_{ghg} - \frac{1}{26}|\omega|_{ghh} - \frac{1}{26}|\omega|_{hhf} - \\
&- \frac{1}{26}|\omega|_{hhg} - \frac{1}{26}|\omega|_{hhh}
\end{aligned} 
\]
Однако если $\omega$ = `h` или $\omega$ = $\varepsilon$ то $M(\omega) = \frac{1}{13}$.
Этот инвариант не убывает при применении любых правил из систем переписывания $\mathcal{T}'$ и $\mathcal{T}$. Коэффициенты этого инварианта было подобраны программно и проверены на контекстах разной длины.

Для проверки была написана программ представленная в Листинге 2.
\begin{lstlisting}
import random
from fractions import Fraction

alphabet = ["f", "g", "h"]
rules = {
    "fgh": "fff",
    "ggg": "fgh",
    "fff": "hhh",
    "ghhh": "hhhg",
    "fh": "hf",
    "hh": "f",
    "ghf": "hfg",
    "hf": "",
    "ff": "h",
    "g": ""
}

def generate_word(min_len, max_len):
    length = random.randint(min_len, max_len)
    return "".join(random.choice(alphabet) for _ in range(length))

def apply_rules_fixed_steps(word, rules, steps):
    for _ in range(steps):
        applicable = [(lhs, rhs) for lhs, rhs in rules.items() if lhs in word]
        if not applicable:
            break 
        lhs, rhs = random.choice(applicable)
        start_idx = random.choice([i for i in range(len(word)) if word.startswith(lhs, i)])
        word = word[:start_idx] + rhs + word[start_idx + len(lhs):]
    return word

def diff_mod3(word):
    return (word.count("f") - word.count("h")) % 3

def invariant_M(w):
    S = ['f','g','h','ff','fg','fh','gf','gg','gh','hf','hg',
         'hh','fff','ffg','ffh','fgf','fgg','fgh','fhf','fhg','fhh',
         'gff','gfg','gfh','ggf','ggg','ggh','ghf','ghg','ghh',
         'hff','hfg','hfh','hgf','hgg','hgh','hhf','hhg','hhh']
    alpha = [
        Fraction(1,13), Fraction(1,13), Fraction(1,26),
        Fraction(-1,13), Fraction(-1,13), Fraction(-1,26),
        Fraction(-1,13), Fraction(-1,13), Fraction(-1,26),
        Fraction(-1,26), Fraction(-1,26), Fraction(0,1),
        Fraction(0,1), Fraction(0,1), Fraction(0,1), Fraction(0,1), Fraction(0,1), Fraction(0,1),
        Fraction(-1,26), Fraction(-1,26), Fraction(-1,26),
        Fraction(0,1), Fraction(0,1), Fraction(0,1), Fraction(0,1), Fraction(0,1), Fraction(0,1),
        Fraction(-1,26), Fraction(-1,26), Fraction(-1,26),
        Fraction(0,1), Fraction(0,1), Fraction(0,1), Fraction(0,1), Fraction(0,1), Fraction(0,1),
        Fraction(-1,26), Fraction(-1,26), Fraction(-1,26),
    ]
    def count_substring(s, w):
        count = 0
        L = len(s)
        for i in range(len(w) - L + 1):
            if w[i:i+L] == s:
                count += 1
        return count
    M = Fraction(0,1)
    for s,a in zip(S, alpha):
        M += a * count_substring(s, w)
    if w == "h" or w == "":
        M = Fraction(1, 13)
    return M

start = generate_word(15, 30)
start_val1 = diff_mod3(start)
start_val2 = invariant_M(start)
    
end = apply_rules_fixed_steps(start, rules, steps=15)
end_val1 = diff_mod3(end)
end_val2 = invariant_M(end)
a1 = start_val1 == end_val1
a2 = start_val2 <= end_val2
if not (a1 and a2):
    print(start_val1 == end_val1)
    print(start_val2 <= end_val2, start_val2, end_val2)
    print(start, end)
\end{lstlisting}



\end{document}